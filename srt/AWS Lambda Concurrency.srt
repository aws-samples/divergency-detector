1
00:00:00,430 --> 00:00:02,320
AWS Lambda Concurrency.

2
00:00:04,270 --> 00:00:07,460
Lambda concurrency is the number of concurrent executions

3
00:00:07,470 --> 00:00:10,060
of your Lambda function code at any given time.

4
00:00:11,090 --> 00:00:13,740
Concurrency is subject to limits at the Region level.

5
00:00:14,380 --> 00:00:19,040
The default concurrency limit for Lambda is 1,000 executions per account per Region.

6
00:00:19,680 --> 00:00:23,280
You can increase the limit by submitting a request in the Support Center console.

7
00:00:25,600 --> 00:00:27,810
When your function is invoked by an event source,

8
00:00:28,180 --> 00:00:30,550
Lambda provisions an instance of it to process it.

9
00:00:31,200 --> 00:00:33,150
When the function code finishes running,

10
00:00:33,450 --> 00:00:34,890
it can handle another request.

11
00:00:37,010 --> 00:00:40,960
If the function is invoked again while a request is still being processed,

12
00:00:41,200 --> 00:00:44,810
another instance is provisioned, increasing the function's concurrency.

13
00:00:45,450 --> 00:00:46,670
In this example above,

14
00:00:46,810 --> 00:00:50,310
it shows the number of Lambda concurrency is increasing from one to three.

15
00:00:52,930 --> 00:00:55,090
Reserved and unreserved concurrency.

16
00:00:55,690 --> 00:00:57,450
Within your account's concurrency limit,

17
00:00:57,490 --> 00:01:01,440
you can configure to reserve a portion of your account-level concurrency limit

18
00:01:01,590 --> 00:01:02,710
for a given function.

19
00:01:04,319 --> 00:01:06,540
This reserved concurrency guarantees that it can

20
00:01:06,540 --> 00:01:08,810
always reach a certain level of concurrency.

21
00:01:08,820 --> 00:01:12,980
The reserved concurrency is also the maximum concurrency for the function.

22
00:01:12,990 --> 00:01:15,550
The remaining are the unreserved concurrency.

23
00:01:15,560 --> 00:01:17,790
All of your account's functions in the same Region

24
00:01:17,790 --> 00:01:21,560
without reserved concurrency share the pool of unreserved concurrency.

25
00:01:23,060 --> 00:01:25,780
There are two key reasons for reserving concurrency.

26
00:01:25,790 --> 00:01:28,840
You can prevent a specific function from consuming the

27
00:01:28,840 --> 00:01:31,040
majority of the concurrency capacity available.

28
00:01:31,600 --> 00:01:33,220
Without reserved concurrency,

29
00:01:33,310 --> 00:01:36,350
other functions can use up all of the available concurrency,

30
00:01:36,360 --> 00:01:38,840
preventing your function from scaling up when needed.

31
00:01:39,480 --> 00:01:43,950
Or a service could consume too much concurrent capacity and

32
00:01:43,950 --> 00:01:46,550
overwhelm downstream services or databases,

33
00:01:46,560 --> 00:01:48,690
which could cause failed executions.

34
00:01:51,420 --> 00:01:53,200
Here's a chef analogy example.

35
00:01:53,720 --> 00:01:56,390
There is a maximum of 10 chefs available for cooking

36
00:01:56,400 --> 00:01:57,750
or executing in

37
00:01:57,870 --> 00:01:59,060
this restaurant's kitchen.

38
00:01:59,660 --> 00:02:01,960
The total maximum concurrency limit is 10.

39
00:02:04,390 --> 00:02:08,520
If the Lambda function doesn't have enough concurrency available to process all events,

40
00:02:08,530 --> 00:02:10,180
additional requests are throttled.

41
00:02:10,660 --> 00:02:12,680
This means while all the 10 chefs are cooking,

42
00:02:13,110 --> 00:02:14,830
the #11 order will be ignored.

43
00:02:17,010 --> 00:02:18,680
Based on the food-orders requests,

44
00:02:18,760 --> 00:02:21,670
only 7 chefs are required to cook at this time.

45
00:02:21,680 --> 00:02:23,520
The consumed concurrency is seven.

46
00:02:24,130 --> 00:02:26,200
After a chef finishes cooking the dish,

47
00:02:26,240 --> 00:02:28,200
the chef returns to the concurrency pool

48
00:02:28,480 --> 00:02:31,500
and will be available immediately to cook again upon requests.

49
00:02:33,070 --> 00:02:34,800
For example, in this restaurant,

50
00:02:34,810 --> 00:02:36,240
chicken is today's special.

51
00:02:36,620 --> 00:02:38,560
Chicken orders have become very popular.

52
00:02:39,210 --> 00:02:42,910
You decide to assign four dedicated chefs to cook chicken dishes only.

53
00:02:44,230 --> 00:02:46,580
The reserved concurrency for the cooking chicken function

54
00:02:46,620 --> 00:02:48,060
is configured to be 4.

55
00:02:49,440 --> 00:02:51,580
The other chefs handle all the other food orders

56
00:02:51,920 --> 00:02:53,320
except for the chicken orders.

57
00:02:54,280 --> 00:02:57,010
The unreserved concurrency is the remaining 6 chefs.

58
00:02:58,090 --> 00:03:00,130
Since all the chefs are cooking at this time,

59
00:03:00,160 --> 00:03:02,340
the consumed reserved concurrency is 4

60
00:03:02,820 --> 00:03:05,350
while the consumed unreserved concurrency is 6.

61
00:03:07,920 --> 00:03:09,980
Let's look at another scenario example.

62
00:03:10,530 --> 00:03:12,840
There are three chicken orders requested at this time.

63
00:03:12,850 --> 00:03:15,850
Therefore, only three reserved chefs are required.

64
00:03:15,860 --> 00:03:18,490
The consumed reserved concurrency is 3.

65
00:03:18,500 --> 00:03:21,500
There are still 1 reserved chef available to cook chicken.

66
00:03:23,270 --> 00:03:24,570
Similarly, this time,

67
00:03:24,580 --> 00:03:28,160
only four chefs are required to cook the other requested food orders.

68
00:03:28,170 --> 00:03:31,440
Therefore, the consumed unreserved concurrency is 4.

69
00:03:31,450 --> 00:03:33,920
Two unreserved chefs are still available.

70
00:03:36,570 --> 00:03:38,800
You can see in this simple analogy how you can

71
00:03:38,840 --> 00:03:40,380
reserve concurrency to meet your needs.

72
00:03:40,940 --> 00:03:43,900
In summary, Lambda concurrency are concurrent executions

73
00:03:44,000 --> 00:03:46,860
that help you to scale and meet traffic demands and requests

74
00:03:47,200 --> 00:03:49,620
with little or no need for capacity planning.

