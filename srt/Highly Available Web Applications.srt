1
00:00:01,120 --> 00:00:03,539
Building Highly Available Web Applications.

2
00:00:05,630 --> 00:00:09,289
A highly available system minimizes service interruptions

3
00:00:09,300 --> 00:00:11,489
 and enables resources to be available when they are needed.

4
00:00:13,220 --> 00:00:16,120
Unfortunately, system failure is unavoidable.

5
00:00:16,309 --> 00:00:20,329
External factors beyond your control may eventually affect your services.

6
00:00:20,649 --> 00:00:23,719
Causes of system failure include natural disasters,

7
00:00:23,729 --> 00:00:26,399
hardware failure. or malicious security events

8
00:00:26,409 --> 00:00:27,559
just to name a few.

9
00:00:28,520 --> 00:00:30,680
These events can have severe implications

10
00:00:30,690 --> 00:00:32,919
for your operations and can cause disruption

11
00:00:32,930 --> 00:00:35,610
of mission critical systems resulting in degradation

12
00:00:35,619 --> 00:00:37,740
of system performance or complete failure.

13
00:00:39,029 --> 00:00:41,700
Moreover, without proper design considerations,

14
00:00:41,709 --> 00:00:44,959
failure of an application in one region may have global impact.

15
00:00:46,729 --> 00:00:50,430
These outages cause customer dissatisfaction which can lead to a lack

16
00:00:50,439 --> 00:00:54,310
of confidence in your services and, ultimately, a downturn in revenue.

17
00:00:57,950 --> 00:01:02,119
Fortunately, with AWS, the effect of these scenarios can be mitigated by building a solid foundation

18
00:01:02,529 --> 00:01:06,319
in AWS's cloud architecting principles and with careful planning and design,

19
00:01:06,949 --> 00:01:10,510
AWS can help you create a highly available application which meets your needs

20
00:01:13,540 --> 00:01:16,120
Principles for Architecting High Availability.

21
00:01:16,839 --> 00:01:18,110
Design for failure.

22
00:01:18,809 --> 00:01:20,589
A system will eventually fail.

23
00:01:20,599 --> 00:01:23,419
Therefore, you must design with this assumption in mind.

24
00:01:23,760 --> 00:01:27,110
If a component fails, the system must continue to run.

25
00:01:27,470 --> 00:01:29,230
This is known as fault tolerance.

26
00:01:30,610 --> 00:01:32,800
One of the simplest manners to improve the fault

27
00:01:32,809 --> 00:01:35,550
tolerance of your system is by introducing redundancy.

28
00:01:36,519 --> 00:01:38,480
When you are creating redundant systems,

29
00:01:38,489 --> 00:01:42,660
consider spreading your services over multiple regions or availability zones.

30
00:01:42,930 --> 00:01:46,410
This will further decrease the probability of overlapping incidents

31
00:01:47,830 --> 00:01:49,889
Embrace elasticity and automation.

32
00:01:51,480 --> 00:01:54,980
AWS provides you with the capability to monitor your resources using AWS CloudWatch.

33
00:01:56,870 --> 00:02:02,129
With CloudWatch. You can track metrics such as CPU, disk, RAM, and network usage.

34
00:02:03,930 --> 00:02:07,290
With these metrics, you can introduce elasticity into your system.

35
00:02:07,300 --> 00:02:09,610
With services such as Auto Scaling groups,

36
00:02:09,990 --> 00:02:12,690
Auto Scaling groups allow you to create a set of rules

37
00:02:12,699 --> 00:02:15,660
to automate the provisioning of your system under different loads.

38
00:02:15,949 --> 00:02:18,699
If your systems are overloaded, they can scale out.

39
00:02:19,020 --> 00:02:22,229
Alternatively. If they are under utilized, you can scale in.

40
00:02:22,630 --> 00:02:25,710
In this way, you can configure your systems dynamically.

41
00:02:27,580 --> 00:02:31,210
Another architectural consideration is to ensure that your system has

42
00:02:31,220 --> 00:02:34,130
the ability to auto heal when a service encounters trouble.

43
00:02:34,479 --> 00:02:36,399
Should a service become unresponsive

44
00:02:36,410 --> 00:02:38,960
you will need to automatically provision a new service.

45
00:02:39,779 --> 00:02:41,360
Loosely coupled components.

46
00:02:42,460 --> 00:02:46,440
Another principle is to ensure your systems aren't highly dependent on each other.

47
00:02:46,750 --> 00:02:48,580
This is known as tightly coupled.

48
00:02:48,880 --> 00:02:52,460
When you have a set of tightly coupled services, should one of them fail,

49
00:02:52,470 --> 00:02:54,699
it can cause a domino effect which can cause the

50
00:02:54,710 --> 00:02:57,350
whole set of services to encounter a fatal error.

51
00:02:57,699 --> 00:03:01,000
Instead, seek to decouple your components from one another.

52
00:03:01,350 --> 00:03:04,220
You can use services such as Elastic Load Balancer as an

53
00:03:04,229 --> 00:03:07,949
intermediary routing traffic to a black box of eligible services.

54
00:03:08,410 --> 00:03:12,639
Another service can be Amazon Simple Queue Service, also known as SQS.

55
00:03:13,690 --> 00:03:17,639
SQS can enable one set of producer services to send messages to a set

56
00:03:17,649 --> 00:03:21,259
of consumers without having to worry if the consumers are active or healthy

57
00:03:21,270 --> 00:03:22,839
at the time when the message is sent.

58
00:03:24,490 --> 00:03:25,789
Become stateless.

59
00:03:26,839 --> 00:03:29,270
Stateful applications hold information regarding the state

60
00:03:29,279 --> 00:03:31,110
of an individual user on a server.

61
00:03:31,369 --> 00:03:34,529
This could include login information and file transfers.

62
00:03:34,800 --> 00:03:37,160
This is problematic in the case where a server fails,

63
00:03:37,169 --> 00:03:40,669
since state information isn't shared across all servers.

64
00:03:41,910 --> 00:03:44,080
This means our data is tightly coupled,

65
00:03:44,089 --> 00:03:46,869
so we're already losing a highly available quality.

66
00:03:47,229 --> 00:03:50,970
Instead, when possible, consider using a stateless protocol.

67
00:03:51,360 --> 00:03:55,750
With a stateless protocol, often seen with RESTful services,

68
00:03:55,759 --> 00:03:59,869
state is not held on the servers, but are held by the user in various forms such as tokens.

69
00:04:00,089 --> 00:04:04,949
State information can also be held by other services such as DynamoDB or Elasticache.

70
00:04:05,850 --> 00:04:10,000
In this scenario, when a server fails, there is no interruption in service.

71
00:04:11,899 --> 00:04:13,169
Use parallelism.

72
00:04:13,440 --> 00:04:16,298
A monolithic application is a piece of self contained

73
00:04:16,309 --> 00:04:19,399
software which has multiple distinct components bundled together.

74
00:04:19,730 --> 00:04:22,190
This piece of software will receive data for all

75
00:04:22,200 --> 00:04:25,399
the components and perform the necessary operations on it.

76
00:04:25,679 --> 00:04:28,160
This can severely reduce performance as the

77
00:04:28,170 --> 00:04:30,489
system attempts to handle varying requests.

78
00:04:31,649 --> 00:04:36,079
Moreover, it is not uncommon to see sub components unnecessarily placed in a linear pipeline.

79
00:04:36,489 --> 00:04:38,950
This can create a bottleneck for task completion

80
00:04:38,959 --> 00:04:41,910
where the longest subtask delays loosely related tasks.

81
00:04:43,899 --> 00:04:46,299
At every opportunity you should transform these

82
00:04:46,309 --> 00:04:49,940
applications into smaller, independent, parallel services.

83
00:04:50,190 --> 00:04:53,339
These small services are aptly called microservices.

84
00:04:53,609 --> 00:04:56,980
Each microservice will receive data pertinent to its function.

85
00:04:57,190 --> 00:05:01,019
Furthermore, these services can allow you to scale more granularly.

86
00:05:02,190 --> 00:05:04,459
Overall, this decreases the chance that any one component

87
00:05:04,470 --> 00:05:06,350
can cause failure of the whole system,

88
00:05:06,359 --> 00:05:08,459
thus increasing the overall availability.

89
00:05:09,910 --> 00:05:11,570
Security as a forethought.

90
00:05:12,459 --> 00:05:14,790
Finally, it is important that security is considered early

91
00:05:14,799 --> 00:05:16,959
and woven into every layer of your system.

92
00:05:17,260 --> 00:05:19,779
Remember to follow security best practices.

93
00:05:19,790 --> 00:05:23,579
These include, but are not limited to setting up governance and compliance,

94
00:05:23,589 --> 00:05:27,410
encrypting your data in transit and at rest, monitoring your resources,

95
00:05:27,420 --> 00:05:28,869
environments and incidents,

96
00:05:28,880 --> 00:05:30,929
and following the principle of least privilege.

